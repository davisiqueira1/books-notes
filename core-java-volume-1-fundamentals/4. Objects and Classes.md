#### 4.1.1 Classes

Initial discussion about encapsulation. Our classes must hide their information (properties and method implementations) by encapsulating them. The book calls it `"black box" behavior`: the user does not need to know the state of an object or how its class implements a method, it just needs to do what it is supposed to do.

To make encapsulation work, programs should interact with object data only through the object's methods. If an object’s state changes without a method call, there's something wrong with our class's encapsulation logic.

#### 4.1.4 Relationships between Classes

Most common relationships between classes are:
- Dependence ("uses-a")
- Aggregation("has-a")
- Inheritance("is-a")

##### Dependence ("uses-a")
The most obvious one. In the context of an order-processing system, the `Order` class uses the `Account` class because `Order` objects need to access `Account` objects to check for credit status.

Thus, a class depends on another class if its methods use or manipulate objects of that class, but it does not own them or maintain a long-term relationship.

This is a weak, temporary relationship, usually happening during a method call.

Example:

```java
class Order {
    public void process(Account account) {
        // Order depends on Account to do its job
        if (account.hasSufficientCredit(this)) {
            // Process it
        } else {
	        // Do something
        }
    }
}
```

##### Aggregation ("has-a")
A class aggregates another class if it contains references to objects that can still exist independently, even if the container is destroyed.

Example:

```java
class Order {
	private List<Item> items;
	
	public Order(List<Item> items) {
		this.items = items;
	}
}
```

##### Inheritance ("is-a")
A class inherits from another class when it reuses its attributes and behaviors, and may also define new attributes or override behaviors.

Example:

```java
class Order {
	public void process(Account account) {
		// Process
	}
}

class RushOrder extends Order {
	private Date expirationDate;
	
	@Override
	public void process(Account account) {
		// Process with priority
	}
}
```

#### 4.2.2 Date and LocalDate Classes
- Date: represents a particular point in time by the number of milliseconds (positive or negative) from a fixed point, the so-called epoch, which is 00:00:00 UTC, January 1, 1970
- LocalDate: represents the familiar calendar notation

Notice that the Java Library separates time measurement from calendar notation, since the same point in time can be represented in many ways depending on the calendar type you are using. Internally, LocalDate keeps a Date object to use as a reference for the point in time it is representing.

#### 4.2.3 Mutator and Accessor Methods
- Mutator method: changes the state of the object after the invocation
- Accessor method: only access objects without modifying them

#### 4.3.8 Benefits of Encapsulation

I've always misunderstood the concept of setters and getters. In my mind, these methods break encapsulation per se.

"If a class has a field that can be modified and accessed through methods, isn't it the same as setting them as public?"

In short: no.

Take the class `Employee` as an example:
```java
class Employee {
	private String name;
	
	public Employee(String name) { this.name = name; }
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
}
```

The only way to modify the `name` attribute is through the `setName` method. So, if we find a case where the value ever turns out wrong, only that method needs to be debugged.

If our `name` attribute were public, any part of the code could modify it, so it would take longer to debug.

Only this should be enough to show us the importance of encapsulation, but let me show you another example. Imagine that our application now needs to store the name in two variables: `firstName` and `lastName`.

If the attribute `name` were public, we would need to check all the places where `employee.name` was accessed.

But with the `getName` method, we would only need to change its implementation to something like:
```java
public String getName() {
	return firstName + " " + lastName;
}
```

And that's the benefit of encapsulation: the internal logic is protected and isolated, allowing easier debugging and new feature implementation.

#### 4.4 Static Fields and Methods

In Java, the `static` keyword means belonging to the class, not to individual objects.

- Static Fields (Class Variables):
    - Shared across all instances of the class.
    - There is only one copy in memory.
    - Commonly used for counters, caches, or shared configuration.
    - Example:
	```java
		class Counter {
			static int count = 0;
		}
	```

- Static Methods:
    - Can be called without creating an object.
    - Cannot access instance variables or instance methods directly.
    - Often used for utility/helper functions.
    - Example:
    ```java
	    class MathUtils {
		    static int square(int x) {
			    return x * x;
			}
		}
    ```

- Static Constants:
    - Declared as `static final`, so they belong to the class and cannot change.
    - Conventionally written in UPPER_CASE.
    - Example:
	```java
		class Physics {
			static final double SPEED_OF_LIGHT = 299_792_458;
		}
	```

- Factory Methods:
	- These are methods (often `static`) used to create instances of a class.
	- They make object creation clearer and more flexible, allowing logic or validation before returning an instance.
	- Commonly used instead of constructors when there are multiple ways to create an object.
	- Example:
	```java
		class Employee {
		    private String name;
		
		    private Employee(String name) {
		        this.name = name;
		    }
		
		    // Factory method
		    public static Employee of(String name) {
		        return new Employee(name.trim());
		    }
		}
	```

#### 4.7 Records

Consider a class Point that describes a point in the plane, with `x` and `y` coordinates:
```java
class Point {
	private final double x;
	private final double y;
	
	public Point (double x, double y) { this.x = x; this.y = y; }
	
	public double getX() { return x; }
	public double getY() { return y; }
	public String toString() { return "Point[x=%d, y=%d]".formatted(x, y); }
	// More methods...
}
```

Would you agree that this code contains quite a bit of boilerplate? Its main purpose is simply to hide the `x` and `y` values and expose them through getters, but, in practice, we will likely never need to change the implementation of this class... so why write all of this?

##### 4.7.1 The Record Concept

A record is a special form of a class whose state is immutable and readable by the public. With it, we can get to the same point (hope you get it) with way less code.

Here's the same class implemented using a record:
```java
record Point(double x, double y) {}
```

The result is a class with:
- Instance fields:
```java
	private final double x;
	private final double y;
```
>  In the Java language specification, the instance fields of a record are called its *components*.
- Constructor:
```java
	public Point(int x, int y) { this.x = x; this.y = y; }
```
- Accessor methods:
```java
	public double x() { return this.x; } 
	public double y() { return this.y; }
```

*Note: in addition to the field accessor methods, every record has three methods defined automatically: toString, equals, and hashCode.*

Use a record instead of a class for immutable data that is completely represented by a set of variables. Use a class if the data is mutable, or if the representation may evolve over time. Records are easier to read, more efficient, and safer in concurrent programs.

##### 4.7.2 Constructors: Canonical, Compact, and Custom

The automatically defined constructor that sets all instance fields is called the *canonical constructor*.

We can add some validation to this constructor using its *compact* form:
```java
record Point(double x, double y) {
	public Point {
		if (x < 10) throw new IllegalArgumentException();
	}
}
```

The body of the compact form is the “prelude” to the canonical constructor. It merely modifies the parameter variables from and to before they are assigned to the instance fields `this.from` and `this.to`. You cannot read or modify the instance fields (calling `this`) in the body of the compact constructor.

You can define additional *custom constructors*. The first statement of such a constructor must call another constructor, so that ultimately the canonical constructor is invoked.

Here is an example:
```java
record Point(double x, double y) {
	public Point() {
		this(0, 0);
	}
}
```

#### 4.8 Packages

Java allows you to group classes in a collection called a package. Packages are convenient for organizing your work and for separating your work from code libraries provided by others.

##### 4.8.1 Package Names

The main reason for using packages is to guarantee the uniqueness of class names. Suppose two programmers come up with the idea of supplying an `Point` class. As long as both of them place their class into different packages, there is no conflict.

##### 4.8.2 Class Importation

A class can use all classes from its own package and all public classes from other packages.

You can access the public classes in another package in two ways. The first is simply to use the fully qualified name; that is, the package name followed by the class name.

For example: 
```java
java.time.LocalDate today = java.time.LocalDate.now();
```

That is obviously tedious.

A simpler, and more common, approach is to use the import statement:
```java
import java.time.LocalDate;
```

##### 4.8.5 Package Access

Features tagged as public can be used by any class. Private features can be used only by the class that defines them. If you don’t specify either public or private, the feature (that is, the class, method, or variable) can be accessed by all methods in the same package.

##### 4.8.6 The Class Path

The classpath tells the Java compiler and JVM where to find classes and resources.

###### How it works:
- Compilation:
    `javac -classpath libs/* src/com/example/App.java`
- Execution:
    `java -classpath bin:libs/* com.example.App`
- Default value: the current directory (`.`).

###### Classpath components:
1. Directories containing compiled `.class` files (e.g., `bin/`, `out/`).
2. JAR files with external dependencies.
3. Source directories when compiling.

The JVM searches the classpath entries in order until it finds the required class.

##### 4.8.7 Setting the Class Path

Using the `-classpath` option is the preferred approach for setting the class path:
```bash
java -classpath /home/ user/ classdir:.:/ home/ user/ archives/ archive.jar MyProg
```

An alternate approach is the CLASSPATH environment variable.
```bash
export CLASSPATH =/ home/ user/ classdir:.:/ home/ user/ archives/ archive.jar
```

> This is generally a bad idea. People forget the global setting, and are surprised when their classes are not loaded properly.

#### 4.9 JAR Files

When you package your application, you want to give your users a single file, not a directory structure filled with class files. Java Archive (JAR) files were designed for this purpose. A JAR file can contain both class files and other file types such as image and sound files. Moreover, JAR files are compressed, using the ZIP compression format.

##### 4.9.1 Creating JAR files

Use the `jar` tool to make JAR files. The most common command to make a new JAR file uses the following syntax:

```bash
jar cvf jarFileName file1 file2 ...
```

You can package application programs and code libraries into JAR files. For example, if you want to send mail in a Java program, you use a library that is packaged in a file javax.mail.jar.

##### 4.9.3 Executable JAR Files

You can use the `e` option of the jar command to specify the entry point of your program (the class that you would normally specify when invoking the java program launcher):
```bash
jar cvfe MyProgram.jar com.mycompany.mypkg.MainAppClass files to add
```

With that, users can simply start the program as:
```bash
java -jar MyProgram.jar
```

Depending on the operating system configuration, users may even be able to launch the application by double-clicking the JAR file icon.

##### 4.9.4 Multi-Release JAR Files

With the introduction of modules and strong encapsulation of packages, some previously accessible internal APIs are no longer available. This may require library providers to distribute different code for different Java versions. Multi-release JARs take care of this use case.

For backward compatibility, version-specific class files are placed in the META-INF/ versions directory:

```
Application.class
BuildingBlocks.class
Util.class
META-INF/
 ├── MANIFEST.MF
 └── versions
     ├── 9
         ├── Application.class
         └── BuildingBlocks.class
     └── 10
         └── BuildingBlocks.class
```

Suppose the Application class makes use of the CssParser class. Then the legacy Application.class file can be compiled to use `com.sun.javafx.css.CssParser`, while the Java 9 version uses `javafx.css.CssParser`.

*Note: Java 8 knows nothing about the META-INF/ versions directory and will simply load the legacy classes.*

To add versioned class files, use the `--release` flag:
```bash
jar uf MyProgram.jar --release 9 Application.class
```

#### 4.11 Class Design Hints

This chapter provides practical guidelines for designing clean, robust classes that follow good OOP practices.

##### 1. Keep Data Private
- Encapsulation is key — always declare instance fields as `private`.
- If access is required, provide **accessor (get)** and **mutator (set)** methods.
- This allows internal representation to change without breaking external code and makes bugs easier to detect.

##### 2. Always Initialize Data
- Java initializes instance fields automatically but not local variables.
- Don’t rely on defaults — explicitly initialize all fields either at declaration or in constructors.

##### 3. Avoid Excessive Use of Primitive Types
- Group related data into new classes instead of multiple primitive fields.
- Example: replace `street`, `city`, `state`, `zip` with an `Address` class, making the code clearer and easier to adapt to changes (e.g., international addresses).

##### 4. Not All Fields Need Getters/Setters
- Provide accessors/mutators only for fields that must be externally read or modified.
- Example: you may need to change salary but not hiring date.

##### 5. Break Up Classes with Too Many Responsibilities
- Split large, complicated classes into smaller ones with clear, single responsibilities.
- Example: separate `CardDeck` (manages the deck) and `Card` (represents a single card).
- Use records for simple data carriers and **enums** for fixed sets of values (e.g., suits).

##### 6. Use Descriptive Names
- Class names should be nouns (`Order`, `BillingAddress`).
- Accessor methods should start with `get`, mutators with `set`.
- Clear names improve readability and maintainability.

##### 7. Prefer Immutable Classes
- Immutable objects (e.g., `LocalDate`) are thread-safe and easier to reason about.
- Instead of mutating objects, return new ones with the updated state.
- Not all classes should be immutable (e.g., `raiseSalary` usually modifies the same `Employee` instance).