#### 4.1.1 Classes

Initial discussion about encapsulation. Our classes must hide their information (properties and method implementations) by encapsulating them. The book calls it `"black box" behavior`: the user does not need to know the state of an object or how its class implements a method, it just needs to do what it is supposed to do.

To make encapsulation work, programs should interact with object data only through the object's methods. If an object’s state changes without a method call, there's something wrong with our class's encapsulation logic.

#### 4.1.4 Relationships between Classes

Most common relationships between classes are:
- Dependence ("uses-a")
- Aggregation("has-a")
- Inheritance("is-a")

##### Dependence ("uses-a")
The most obvious one. In the context of an order-processing system, the `Order` class uses the `Account` class because `Order` objects need to access `Account` objects to check for credit status.

Thus, a class depends on another class if its methods use or manipulate objects of that class, but it does not own them or maintain a long-term relationship.

This is a weak, temporary relationship, usually happening during a method call.

Example:

```java
class Order {
    public void process(Account account) {
        // Order depends on Account to do its job
        if (account.hasSufficientCredit(this)) {
            // Process it
        } else {
	        // Do something
        }
    }
}
```

##### Aggregation ("has-a")
A class aggregates another class if it contains references to objects that can still exist independently, even if the container is destroyed.

Example:

```java
class Order {
	private List<Item> items;
	
	public Order(List<Item> items) {
		this.items = items;
	}
}
```

##### Inheritance ("is-a")
A class inherits from another class when it reuses its attributes and behaviors, and may also define new attributes or override behaviors.

Example:

```java
class Order {
	public void process(Account account) {
		// Process
	}
}

class RushOrder extends Order {
	private Date expirationDate;
	
	@Override
	public void process(Account account) {
		// Process with priority
	}
}
```

#### 4.2.2 Date and LocalDate Classes
- Date: represents a particular point in time by the number of milliseconds (positive or negative) from a fixed point, the so-called epoch, which is 00:00:00 UTC, January 1, 1970
- LocalDate: represents the familiar calendar notation

Notice that the Java Library separates time measurement from calendar notation, since the same point in time can be represented in many ways depending on the calendar type you are using. Internally, LocalDate keeps a Date object to use as a reference for the point in time it is representing.

#### 4.2.3 Mutator and Accessor Methods
- Mutator method: changes the state of the object after the invocation
- Accessor method: only access objects without modifying them

#### 4.3.8 Benefits of Encapsulation

I've always misunderstood the concept of setters and getters. In my mind, these methods break encapsulation per se.

"If a class has a field that can be modified and accessed through methods, isn't it the same as setting them as public?"

In short: no.

Take the class `Employee` as an example:
```java
class Employee {
	private String name;
	
	public Employee(String name) { this.name = name; }
	
	public void setName(String name) {
		this.name = name;
	}
	
	public String getName() {
		return name;
	}
}
```

The only way to modify the `name` attribute is through the `setName` method. So, if we find a case where the value ever turns out wrong, only that method needs to be debugged.

If our `name` attribute were public, any part of the code could modify it, so it would take longer to debug.

Only this should be enough to show us the importance of encapsulation, but let me show you another example. Imagine that our application now needs to store the name in two variables: `firstName` and `lastName`.

If the attribute `name` were public, we would need to check all the places where `employee.name` was accessed.

But with the `getName` method, we would only need to change its implementation to something like:
```java
public String getName() {
	return firstName + " " + lastName;
}
```

And that's the benefit of encapsulation: the internal logic is protected and isolated, allowing easier debugging and new feature implementation.

#### 4.4 Static Fields and Methods

In Java, the `static` keyword means belonging to the class, not to individual objects.

- Static Fields (Class Variables):
    - Shared across all instances of the class.
    - There is only one copy in memory.
    - Commonly used for counters, caches, or shared configuration.
    - Example:
	```java
		class Counter {
			static int count = 0;
		}
	```

- Static Methods:
    - Can be called without creating an object.
    - Cannot access instance variables or instance methods directly.
    - Often used for utility/helper functions.
    - Example:
    ```java
	    class MathUtils {
		    static int square(int x) {
			    return x * x;
			}
		}
    ```

- Static Constants:
    - Declared as `static final`, so they belong to the class and cannot change.
    - Conventionally written in UPPER_CASE.
    - Example:
	```java
		class Physics {
			static final double SPEED_OF_LIGHT = 299_792_458;
		}
	```

- Factory Methods:
	- These are methods (often `static`) used to create instances of a class.
	- They make object creation clearer and more flexible, allowing logic or validation before returning an instance.
	- Commonly used instead of constructors when there are multiple ways to create an object.
	- Example:
	```java
		class Employee {
		    private String name;
		
		    private Employee(String name) {
		        this.name = name;
		    }
		
		    // Factory method
		    public static Employee of(String name) {
		        return new Employee(name.trim());
		    }
		}
	```

#### 4.7 Records

Consider a class Point that describes a point in the plane, with `x` and `y` coordinates:
```java
class Point {
	private final double x;
	private final double y;
	
	public Point (double x, double y) { this.x = x; this.y = y; }
	
	public double getX() { return x; }
	public double getY() { return y; }
	public String toString() { return "Point[x=%d, y=%d]".formatted(x, y); }
	// More methods...
}
```

Would you agree that this code contains quite a bit of boilerplate? Its main purpose is simply to hide the `x` and `y` values and expose them through getters, but, in practice, we will likely never need to change the implementation of this class... so why write all of this?

##### 4.7.1 The Record Concept

A record is a special form of a class whose state is immutable and readable by the public. With it, we can get to the same point (hope you get it) with way less code.

Here's the same class implemented using a record:
```java
record Point(double x, double y) {}
```

The result is a class with:
- Instance fields:
```java
	private final double x;
	private final double y;
```
>  In the Java language specification, the instance fields of a record are called its *components*.
- Constructor:
```java
	public Point(int x, int y) { this.x = x; this.y = y; }
```
- Accessor methods:
```java
	public double x() { return this.x; } 
	public double y() { return this.y; }
```

*Note: in addition to the field accessor methods, every record has three methods defined automatically: toString, equals, and hashCode.*

Use a record instead of a class for immutable data that is completely represented by a set of variables. Use a class if the data is mutable, or if the representation may evolve over time. Records are easier to read, more efficient, and safer in concurrent programs.

##### 4.7.2 Constructors: Canonical, Compact, and Custom

The automatically defined constructor that sets all instance fields is called the *canonical constructor*.

We can add some validation to this constructor using its *compact* form:
```java
record Point(double x, double y) {
	public Point {
		if (x < 10) throw new IllegalArgumentException();
	}
}
```

The body of the compact form is the “prelude” to the canonical constructor. It merely modifies the parameter variables from and to before they are assigned to the instance fields `this.from` and `this.to`. You cannot read or modify the instance fields (calling `this`) in the body of the compact constructor.

You can define additional *custom constructors*. The first statement of such a constructor must call another constructor, so that ultimately the canonical constructor is invoked.

Here is an example:
```java
record Point(double x, double y) {
	public Point() {
		this(0, 0);
	}
}
```
