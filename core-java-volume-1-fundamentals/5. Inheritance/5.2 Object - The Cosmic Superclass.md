The `Object` class is the ultimate ancestor: every class in Java extends `Object`. However, you never have to write `public class Employee extends Object`.

The ultimate superclass `Object` is taken for granted if no superclass is explicitly mentioned.

#### 5.2.1 Variables of Type Object

You can use a variable of type `Object` to refer to objects of any type:
```java
Object obj = new Employee(...);
```

In java, only the values of _primitive types_ (numbers, characters, and boolean values) are not objects.

All array types, no matter whether they are arrays of objects or arrays of primitive types, are class types that extend the `Object` class.

#### 5.2.2 The equals Method

The `equals` method in the `Object` class tests whether one object is considered equal to another. The `equals` method, as implemented in the `Object` class, determines whether two object references are identical. This is a pretty reasonable default: if two objects are identical, they should certainly be equal. For quite a few classes, nothing else is required.

> Note: the static method `Object.equals(a, b)` is `true` if both arguments are `null`, `false` if only one is `null`, and `a.equals(b)` otherwise. It is very useful for null safety.

When you define the `equals` method for a subclass, first call `equals` on the superclass. If that test doesn't pass, then the objects can't be equal. If the superclass fields are equal, you are ready to compare the instance fields of the subclass.

But remember: inside `super.equals(...)`, `this` is **still the runtime object** (e.g. a subclass instance).

If the superclass uses
```java
if (getClass() != otherObject.getClass()) {
	return false;
}
```
it performs a strict class check, so `super.equals` will return `false` if `this` and `otherObject` have different runtime classes, even if their fields match. To allow comparisons across subclasses, prefer using `instanceof` in the superclass `equals`.

> Note: Records automatically define an `equals` method that compares the fields defined in the _canonical constructor_. Two record instances are equal when the corresponding field values are equal.

#### 5.2.3 Equality Testing and Inheritance

As said before, many programmers use an `instanceof` test instead of a `getClass` test:
```java
if (!(otherObject instanceof Employee)) {
	return false;
}
```
This leaves open the possibility that `otherObject` can belong to a subclass.

However, this approach can get you into trouble. Here is why: the Java Language Specification requires that the `equals` method has the following properties:

1. It is _reflexive_: For any non-null reference `x`, `x.equal(x)` should return `true`.
2. It is _symmetric_: For any references `x` and `y`, `x.equals(y)` should return `true` if and only if `y.equals(x)` returns `true`.
3. It is _transitive_. For any references `x`, `y`, and `z`, if `.xequals(y)` returns `true` and `y.equals(z)` returns `true`, then `x.equals(z)` should return `true`.
4. It is _consistent_: If the objects to which `x` and `y` refer haven't changed, then repeated calls to `x.equals(y)` return the same value.
5. For any non-null reference `x`, `x.equals(null)` should return `false`.

However, the symmetry rule has subtle consequences when parameters belong to different classes.

Consider a call `e.equals(m)` where `e` is an `Employee` object and `m` is a `Manager` object, both of which happen to have the same name, salary, and hire date. If `Employee.equals` uses an `instanceof` test, the call returns `true`. But that means that the reverse call `m.equals(e)` also needs to return true.

That leaves the `Manager` class in a bind. Its `equals` method must be willing to compare itself to any `Employee`, without taking manager-specific information into account! All of a sudden, the `instanceof` test looks less attractive.

The way I see it, there are two distinct scenarios:
- If subclasses can have their own notion of equality, then the symmetry requirement forces you to use the `getClass` test.
- If the notion of equality is fixed in the superclass, then you can use the `instanceof`  test and allow objects of different subclasses to be equal to one another.

In the example with employees and managers, we consider two objects to be equal when they have matching fields. If we have two `Manager` objects with the same name, salary, and hire date, but with different bonuses, we want them to be different. Therefore, we use the `getClass` test.

But suppose we used an employee ID for equality testing. This notion of equality makes sense for all subclasses. Then we could use the `instanceof` test, and we should have declared `Employee.equals` as final.