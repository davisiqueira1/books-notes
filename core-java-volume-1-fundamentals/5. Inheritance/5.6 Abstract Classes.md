As you move up the inheritance hierarchy, classes become more general and probably more abstract. At some point, the ancestor class becomes so general that you think of it more as a basis for other classes than as a class with specific instances you want to use.

Example:
![[abstract_classes.png]]

Abstract classes in Java are used as **blueprints** for other classes. They cannot be instantiated directly: you use them to define common attributes and behaviors that subclasses will share.

In the example above, `Person` would be an abstract class because it represents a generic concept. It might define fields like `name` and `age`, and methods like `getName()`, but it could also contain _abstract methods_ (methods without implementation) that subclasses like `Employee` and `Student` must implement. For example, `getRoleDescription()`.

Abstract classes are useful when:
- You want to share common code between multiple related classes.
- You want to enforce that all subclasses implement certain behaviors.
- You want to prevent creating objects of a class that is too generic to make sense on its own.

This makes them perfect for building hierarchies where the parent is a concept (like `Person`) and only the children represent real, instantiable objects.