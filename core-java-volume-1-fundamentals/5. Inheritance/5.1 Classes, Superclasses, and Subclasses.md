#### 5.1.1 Defining subclasses

Here is how you define a Manager class that inherits from the Employee class:

```java
public class Manager extends Employee {
	// added methods and fields
}
```

The existing class (Employee) is called the _superclass_, _base class_, or _parent class_. The new class is called the _subclass_, _derived class_, or _child class_.

The Employee class is a superclass, but not because it is superior to its subclass or contains more functionality. In fact, the opposite is true: **subclasses have more functionality than their superclasses**.

> Note: The prefixes _super_ and _sub_ come from the language of sets used in theoretical computer science and mathematics. The set of all employees contains the set of all managers, and thus is said to be a _superset_ of the set of managers. Or, to put it another way, the set of all managers is a _subset_ of the set of all employees.

> Note 2: The Java language specification states: “Members of a class that are declared private are not inherited by subclasses of that class.” This has confused my readers over the years. The specification uses the word “inherits” narrowly. It considers the private fields non-inherited because the Manager class cannot access them directly. Thus, every Manager object has three fields from the superclass, but the Manager class does not “inherit” them.

Our `Manager` class has a new field to store the bonus, and a new method to set it:

```java
public class Manager extends Employee {
	private double bonus;
	// ...
	public void setBonus(double bonus) {
		this.bonus = bonus;
	}
}
```

Every Manager object has four fields: name, salary, hireDay, and bonus. The fields name, salary, and hireDay are taken from the superclass.

When designing classes, you place the most general methods in the superclass and more specialized methods in its subclasses. Factoring out common functionality by moving it to a superclass is routine in object-oriented programming.

> Note: You cannot extend a record ([[4.7 Records]]), and a record cannot extend another class. It state is entirely defined by the constructor parameters.

#### 5.1.2 Overriding methods

- You can override public or protected methods (like getSalary()).
- You cannot override private methods — they aren’t inherited.

If you declare a method with the same name/signature in the subclass, it’s just a new method, not an override.

Example:

```java
class Employee {
    private double salary;

    private double getSalary() { return salary; } // private: cannot be overridden
}

class Manager extends Employee {
    @Override // COMPILER ERROR – no method to override
    private double getSalary() { return 0; }
}

```

But with `public` or `protected`:

```java
class Employee {
    protected double getSalary() { return salary; }
}

class Manager extends Employee {
    @Override
    protected double getSalary() { return super.getSalary() + bonus; } // correct
}

```

> Note: Always annotate overridden methods with `@Override`. It makes the compiler check that you are really overriding a method (not accidentally overloading with a different signature).

#### 5.1.3 Subclass Constructors

To complete our example, let us supply `Manager` a constructor:

```java
public Manager(String name, double salary) {
	super(name, salary);
	this.bonus = 0;
}
```

Here, the instruction `super(name, salary);` is shorthand for "call the constructor of the `Employee` superclass with name and salary as arguments".

Since the `Manager` constructor cannot access the private fields of the `Employee` class, it must initialize them through a constructor. The call using `super` must be the first statement in the constructor for the subclass.

> Note: When a subclass object is constructed without an explicit invocation of a superclass constructor, the superclass must have a no-argument constructor. That constructor is invoked prior to the subclass construction.

#### 5.1.4 Inheritance Hierarchies

Inheritance need not stop at deriving one layer of classes. We could have an `Executive` class that extends `Manager`, for example. The collection of all classes extending a common superclass is called and _inheritance hierarchy_. The path from a particular class to its ancestors in the inheritance hierarchy is its _inheritance chain_.

![[inheritance_hierarchies.png]]
#### 5.1.5 Polymorphism

A simple rule can help you decide whether or not inheritance is the right design for your data. The "is-a" rule states that every object of the subclass is an object of the superclass. For example, every manager is an employee. Naturally, the opposite is not true: not every employee is a manager.

Another way of formulating the "is-a" rule is the _substitution principle_. That principle states that you can use a subclass object whenever the program expects a superclass object.

Example:

```java
Employee e;
e = new Employee(...); // Expected
e = new Manager(...); // Ok as well
```

In the Java programming language, object variables are _polymorphic_. A variable of type `Employee` can refer to an object of type `Employee` or to an object of any subclass of the `Employee` class (such as `Manager`, `Secretary`, `Executive`, `Programmer`, and so on).

When `e` refers to an `Employee` object, the call `e.getSalary()` calls the `getSalary` method of the `Employee` class. However, when `e` refers to a `Manager` object, then the `getSalary` method of the `Manager` class is called instead.

The fact that an object variable (such as the variable `e`) can refer to multiple actual types is called _polymorphism_. Automatically selecting the appropriate method at runtime is called _dynamic binding_.

#### 5.1.6 Understanding Method Calls

It is important to understand exactly how a method call is applied to an object. Let's say we call `x.f(args)`, and the implicit argument `x` is declared to be an object of class `C`. Here is what happens:

1. The compiler looks at the declared type of the object and the method name. Note that there may be multiple methods, all with the same name, `f`, but with different parameter types. The compiler enumerates all methods called `f` in the class `C` and all accessible methods called `f` in the superclasses of `C`. (Private methods of the superclass are not accessible)

2. Next, the compiler determines the types of the arguments supplied in the method call. If among all the methods called `f` there is a unique method whose parameter types are a best match for the supplied arguments, that method is chosen to be called. This process is called *overloading resolution*. If the compiler cannot find any method with matching parameter types or if multiple methods all match after applying conversions, the compiler reports an error.

> Note: The return type is not part of the signature. However, when you override a method, you need to keep the return type compatible. A subclass may change the return type to a subtype of the original type. Example: `Employee` to `Manager`.

3. If the method is `private`, `static`, `final`, or a constructor, then the compiler knows exactly which method to call. This is called *static binding*. Otherwise, the method to be called depends on the actual type of the implicit argument, and *dynamic binding* must be used at runtime.

4. When the program runs and uses *dynamic binding* to call a method, the virtual machine must call the version of the method that is appropriate for the *actual* type of the object to which `x` refers. Let's say the actual type is `D`, a subclass of `C`. If the class `D` defines a method `f(String)`, that method is called, If not, `D`'s superclass is searched for a method `f(String)`, and so on.

> Note: It would be time-consuming to carry out this search every time a method is called. Instead, the virtual machine precomputes a *method table* for each class. The method table lists all method signatures and the actual methods to be called. The virtual machine can build the method table after loading a class, by combining the methods that it find in the class file with the method table of the superclass.

Example:
```java
Employee e;
e = new Manager(...);

e.getSalary();
```

At runtime, the call `e.getSalary()` is resolved as follows: *(remember that we overrode the `getSalary` method in the `Manager` class)*

1. First, the virtual machine fetches the method table for the actual type of `e`. That may be the table for `Employee`, `Manager`, or another subclass of `Employee`.
2. Then, the virtual machine looks up the defining class for the `getSalary()` signature. Now it knows which method to call.
3. Finally, the virtual machine calls the method.

Dynamic binding has a very important property: It makes programs *extensible* without the need for modifying existing code.

#### 5.1.7 Preventing Inheritance: Final Classes and Methods

Occasionally, you want to prevent someone from forming a subclass of one of your classes. Classes that cannot be extended are called _final_ classes, and you use the `final` modifier in the definition of the class to indicate it.

```java
public final class Executive extends Manager {
	...
}
```

You can also make a specific method in a class final. If you do this, then no subclass can override that method. (All methods in a `final` class are automatically final.). Exemplo:

```java
public class Employee {
	...
	public final String getName() {
		return name;
	}
	...
}
```

> Note: Recall that fields can also be declared as final. A final field cannot be changed after the object has been constructed. However, if a class is declared final, only the methods, not the fields, are automatically final.

If you call a method in a constructor, you should declare it as `final`. Otherwise, it can be overridden in a subclass, and it can access a partially constructed subclass instance.

Calling a method in a constructor is inherently dangerous. The constructor must have done enough work for the method to succeed. If the method can be overridden, this becomes very difficult to ensure. Therefore, it is best to call only `final` or private methods in a constructor.

#### 5.1.8 Casting

Casting in Java is used to convert a reference from one type to another within the same inheritance hierarchy. Upcasting (assigning a subclass to a superclass variable) is automatic and safe, while downcasting (casting back to the subclass) must be explicit and can fail at runtime with a `ClassCastException`. To avoid this, check with `instanceof` before casting. Most of the time, casting is unnecessary because polymorphism ensures the correct method is called; you only need it to access methods unique to the subclass.

```java
Employee emp = new Manager("Alice", 50000, 5000); // upcasting
System.out.println(emp.getSalary()); // works (polymorphism)

if (emp instanceof Manager) {
    Manager mgr = (Manager) emp; // safe downcast
    mgr.setBonus(10000);
}
```

#### 5.1.10 Protected Access

As you know, fields in a class are best tagged as private, and methods are usually tagged as public. Any features declared private won’t be accessible in other classes.

There are times when you want to restrict a method to subclasses only or, less commonly, to allow subclass methods to access a superclass field. In that case, you declare a class feature as protected. For example, if the superclass `Employee` declares the `hireDay` field as protected instead of private, then the `Manager` methods can access it directly.

In practice, use protected fields with caution. Suppose your class is used by other programmers and you designed it with protected fields. Unknown to you, other programmers may inherit classes from your class and start accessing your protected fields. In this case, you can no longer change the implementation of your class without upsetting those programmers. That is against the spirit of OOP, which encourages data encapsulation.

Protected methods make more sense. A class may declare a method as protected if it is tricky to use. This indicates that the subclasses (which, presumably, know their ancestor well) can be trusted to use the method correctly, but other classes cannot.

Here is a summary of the four access control modifiers in Java:
1. Accessible in the class only (private).
2. Accessible by the world (public).
3. Accessible in the package and all subclasses (protected).
4. Accessible in the package (the default package). No modifiers are needed.