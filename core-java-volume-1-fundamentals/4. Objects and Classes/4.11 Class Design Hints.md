This chapter provides practical guidelines for designing clean, robust classes that follow good OOP practices.

##### 1. Keep Data Private
- Encapsulation is key — always declare instance fields as `private`.
- If access is required, provide **accessor (get)** and **mutator (set)** methods.
- This allows internal representation to change without breaking external code and makes bugs easier to detect.

##### 2. Always Initialize Data
- Java initializes instance fields automatically but not local variables.
- Don’t rely on defaults — explicitly initialize all fields either at declaration or in constructors.

##### 3. Avoid Excessive Use of Primitive Types
- Group related data into new classes instead of multiple primitive fields.
- Example: replace `street`, `city`, `state`, `zip` with an `Address` class, making the code clearer and easier to adapt to changes (e.g., international addresses).

##### 4. Not All Fields Need Getters/Setters
- Provide accessors/mutators only for fields that must be externally read or modified.
- Example: you may need to change salary but not hiring date.

##### 5. Break Up Classes with Too Many Responsibilities
- Split large, complicated classes into smaller ones with clear, single responsibilities.
- Example: separate `CardDeck` (manages the deck) and `Card` (represents a single card).
- Use records for simple data carriers and **enums** for fixed sets of values (e.g., suits).

##### 6. Use Descriptive Names
- Class names should be nouns (`Order`, `BillingAddress`).
- Accessor methods should start with `get`, mutators with `set`.
- Clear names improve readability and maintainability.

##### 7. Prefer Immutable Classes
- Immutable objects (e.g., `LocalDate`) are thread-safe and easier to reason about.
- Instead of mutating objects, return new ones with the updated state.
- Not all classes should be immutable (e.g., `raiseSalary` usually modifies the same `Employee` instance).