Consider a class Point that describes a point in the plane, with `x` and `y` coordinates:
```java
class Point {
	private final double x;
	private final double y;
	
	public Point (double x, double y) { this.x = x; this.y = y; }
	
	public double getX() { return x; }
	public double getY() { return y; }
	public String toString() { return "Point[x=%d, y=%d]".formatted(x, y); }
	// More methods...
}
```

Would you agree that this code contains quite a bit of boilerplate? Its main purpose is simply to hide the `x` and `y` values and expose them through getters, but, in practice, we will likely never need to change the implementation of this class... so why write all of this?

##### 4.7.1 The Record Concept

A record is a special form of a class whose state is immutable and readable by the public. With it, we can get to the same point (hope you get it) with way less code.

Here's the same class implemented using a record:
```java
record Point(double x, double y) {}
```

The result is a class with:
- Instance fields:
```java
	private final double x;
	private final double y;
```
>  In the Java language specification, the instance fields of a record are called its *components*.
- Constructor:
```java
	public Point(int x, int y) { this.x = x; this.y = y; }
```
- Accessor methods:
```java
	public double x() { return this.x; } 
	public double y() { return this.y; }
```

*Note: in addition to the field accessor methods, every record has three methods defined automatically: toString, equals, and hashCode.*

Use a record instead of a class for immutable data that is completely represented by a set of variables. Use a class if the data is mutable, or if the representation may evolve over time. Records are easier to read, more efficient, and safer in concurrent programs.

##### 4.7.2 Constructors: Canonical, Compact, and Custom

The automatically defined constructor that sets all instance fields is called the *canonical constructor*.

We can add some validation to this constructor using its *compact* form:
```java
record Point(double x, double y) {
	public Point {
		if (x < 10) throw new IllegalArgumentException();
	}
}
```

The body of the compact form is the “prelude” to the canonical constructor. It merely modifies the parameter variables from and to before they are assigned to the instance fields `this.from` and `this.to`. You cannot read or modify the instance fields (calling `this`) in the body of the compact constructor.

You can define additional *custom constructors*. The first statement of such a constructor must call another constructor, so that ultimately the canonical constructor is invoked.

Here is an example:
```java
record Point(double x, double y) {
	public Point() {
		this(0, 0);
	}
}
```